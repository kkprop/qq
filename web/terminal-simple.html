<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QQ Terminal - Pure Tmux Mirroring</title>
    
    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .terminal-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000000;
        }
        
        .terminal-header {
            background: #2d2d2d;
            color: #ffffff;
            padding: 8px 16px;
            font-size: 14px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .session-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .session-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
        }
        
        .session-status.connected { background-color: #4CAF50; }
        .session-status.connecting { background-color: #FF9800; }
        .session-status.disconnected { background-color: #F44336; }
        
        .terminal-controls {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            background: #444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: #555;
        }
        
        .terminal-wrapper {
            position: absolute;
            top: 40px;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 8px;
            /* Enable scrollbar */
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Custom scrollbar styling */
        .terminal-wrapper::-webkit-scrollbar {
            width: 12px;
        }
        
        .terminal-wrapper::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 6px;
        }
        
        .terminal-wrapper::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 6px;
        }
        
        .terminal-wrapper::-webkit-scrollbar-thumb:hover {
            background: #888;
        }
        
        #terminal {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="session-info">
                <div class="session-status" id="sessionStatus"></div>
                <span id="sessionName">Pure Tmux Mirror</span>
                <span id="sessionDetails">Ready to connect...</span>
            </div>
            <div class="terminal-controls">
                <button class="control-btn" onclick="terminal.clear()">Clear</button>
                <button class="control-btn" onclick="reconnectWebSocket()">Reconnect</button>
                <button class="control-btn" onclick="window.open('/web/dashboard.html', '_blank')">Dashboard</button>
            </div>
        </div>
        
        <div class="terminal-wrapper">
            <div id="terminal"></div>
        </div>
    </div>

    <!-- xterm.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>

    <script>
        // Debug xterm.js loading
        console.log('üîç Checking xterm.js availability...');
        console.log('Terminal class:', typeof Terminal);
        console.log('FitAddon class:', typeof FitAddon);
        console.log('WebLinksAddon class:', typeof WebLinksAddon);
        
        // Terminal setup with error handling
        let terminal, fitAddon, webLinksAddon;
        
        try {
            console.log('üîß Creating terminal instance...');
            terminal = new Terminal({
                cursorBlink: true,
                cursorStyle: 'block',
                fontSize: 14,
                fontFamily: 'Courier New, monospace',
                theme: {
                    background: '#000000',
                    foreground: '#ffffff',
                    cursor: '#ffffff',
                    selection: '#ffffff40'
                },
                cols: 120,
                rows: 40
            });
            console.log('‚úÖ Terminal instance created');
            
            // Add-ons with error handling
            console.log('üîß Creating add-ons...');
            fitAddon = new FitAddon.FitAddon();
            webLinksAddon = new WebLinksAddon.WebLinksAddon();
            console.log('‚úÖ Add-ons created');
            
            console.log('üîß Loading add-ons...');
            terminal.loadAddon(fitAddon);
            terminal.loadAddon(webLinksAddon);
            console.log('‚úÖ Add-ons loaded');

            // Mount terminal with error handling
            console.log('üîß Opening terminal...');
            const terminalElement = document.getElementById('terminal');
            console.log('Terminal element:', terminalElement);
            
            terminal.open(terminalElement);
            console.log('‚úÖ Terminal opened');
            
            // Fit terminal
            console.log('üîß Fitting terminal...');
            fitAddon.fit();
            console.log('‚úÖ Terminal fitted');
            
            // Check if xterm elements were created
            setTimeout(() => {
                console.log('üîç Checking xterm DOM elements...');
                const xtermElements = document.querySelectorAll('.xterm');
                const xtermViewport = document.querySelector('.xterm-viewport');
                const xtermScreen = document.querySelector('.xterm-screen');
                
                console.log('Xterm elements:', xtermElements.length);
                console.log('Xterm viewport:', xtermViewport ? 'Found' : 'Not found');
                console.log('Xterm screen:', xtermScreen ? 'Found' : 'Not found');
                
                if (xtermViewport) {
                    console.log('‚úÖ Xterm viewport created successfully');
                    console.log('Viewport dimensions:', {
                        scrollHeight: xtermViewport.scrollHeight,
                        clientHeight: xtermViewport.clientHeight,
                        scrollTop: xtermViewport.scrollTop
                    });
                } else {
                    console.log('‚ùå Xterm viewport not created - this is why scrolling fails!');
                }
            }, 1000);
            
        } catch (error) {
            console.error('‚ùå Terminal initialization failed:', error);
            document.getElementById('terminal').innerHTML = 
                '<div style="color: red; padding: 20px;">‚ùå Terminal initialization failed: ' + error.message + '</div>';
        }

        // WebSocket connection
        let ws = null;
        let currentSessionId = 'qq-default';
        let invisibleInputBuffer = '';
        
        // Continuous scrollable buffer state
        let historyBuffer = [];
        let loadedHistoryLines = 0;
        let totalHistoryLines = 0;
        let isLoadingHistory = false;

        // Simple real-time duplicate filtering - compare with last sent command
        let commandHistory = [];
        let historyIndex = 0;
        let lastSentCommand = '';
        
        terminal.onData(function(data) {
            try {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    return; // Silent failure - let tmux handle everything
                }
                
                if (data === '\u0003') {
                    // Ctrl+C - send interrupt
                    ws.send(JSON.stringify({
                        type: 'interrupt',
                        session: currentSessionId
                    }));
                    invisibleInputBuffer = '';
                    return;
                } else if (data === '\r') {
                    // Enter key - send command completely invisibly
                    if (invisibleInputBuffer.trim()) {
                        // Store the command for duplicate filtering
                        lastSentCommand = invisibleInputBuffer.trim();
                        
                        // Add to history for potential future use
                        commandHistory.push(invisibleInputBuffer.trim());
                        historyIndex = commandHistory.length;
                        
                        // EXPERIMENTAL: Clear any potential browser display
                        // This ensures nothing shows from browser side
                        terminal.write('\r\x1b[2K'); // Clear current line
                        
                        // Send command - this will appear via tmux mirroring only
                        ws.send(JSON.stringify({
                            type: 'command',
                            content: invisibleInputBuffer.trim(),
                            session: currentSessionId
                        }));
                        
                        console.log('ü§´ Command sent invisibly:', invisibleInputBuffer.trim());
                        console.log('üîç Will filter duplicates of:', lastSentCommand);
                        console.log('üßπ Cleared browser display to prevent any local echo');
                    }
                    invisibleInputBuffer = '';
                    return;
                } else if (data === '\u007f' || data === '\b') {
                    // Backspace - modify invisible buffer only
                    if (invisibleInputBuffer.length > 0) {
                        invisibleInputBuffer = invisibleInputBuffer.slice(0, -1);
                    }
                    return;
                } else if (data.length === 1 && data.charCodeAt(0) >= 32) {
                    // Regular character - add to invisible buffer, show nothing
                    invisibleInputBuffer += data;
                    return;
                }
                
                // All other input ignored - tmux handles everything
                
            } catch (error) {
                console.error('Error in input handler:', error);
            }
        });

        // Enhanced duplicate detection with comprehensive debugging
        function isDuplicateOfLastCommand(content) {
            if (!lastSentCommand || !content) return false;
            
            const cleanContent = content.trim();
            
            // Debug logging
            console.log('üîç Checking for duplicate:');
            console.log('  Last sent:', JSON.stringify(lastSentCommand));
            console.log('  Incoming:', JSON.stringify(cleanContent));
            
            // Check exact match
            if (cleanContent === lastSentCommand) {
                console.log('‚úÖ EXACT MATCH - filtering duplicate');
                return true;
            }
            
            // Check if content is the command without $ prompt
            const commandWithoutPrompt = lastSentCommand.replace(/^\$\s*/, '').trim();
            if (cleanContent === commandWithoutPrompt) {
                console.log('‚úÖ COMMAND MATCH (without $) - filtering duplicate');
                return true;
            }
            
            // Check if incoming content contains the command
            if (cleanContent.includes(lastSentCommand.trim())) {
                console.log('‚úÖ CONTAINS MATCH - filtering duplicate');
                return true;
            }
            
            // Check if incoming content is just the command part
            if (lastSentCommand.includes(cleanContent) && cleanContent.length > 5) {
                console.log('‚úÖ PARTIAL MATCH - filtering duplicate');
                return true;
            }
            
            console.log('‚ùå No match - allowing content');
            return false;
        }

        // WebSocket connection management
        function connectWebSocket() {
            updateConnectionStatus('connecting', 'Connecting...');
            
            try {
                console.log(`üîå Attempting WebSocket connection to: ws://localhost:9091/terminal/${currentSessionId}`);
                ws = new WebSocket(`ws://localhost:9091/terminal/${currentSessionId}`);
                
                ws.onopen = function() {
                    console.log('‚úÖ WebSocket connected');
                    updateConnectionStatus('connected', `Connected to ${currentSessionId}`);
                    
                    // Send welcome message
                    terminal.writeln('ü§ñ Pure Tmux Mirror Connected!');
                    terminal.writeln('=====================================');
                    terminal.writeln(`üì° Session: ${currentSessionId}`);
                    terminal.writeln('üéØ Pure tmux mirroring - no browser display interference');
                    terminal.writeln('üí° Type commands - they will appear via tmux mirroring');
                    terminal.writeln('');
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì® WebSocket message:', data.type);
                        
                        switch(data.type) {
                            case 'tmux-current-page':
                                // Initialize continuous buffer
                                console.log('üìÑ Current page received:', data.currentPageLines, 'lines');
                                if (data.content) {
                                    const currentLines = data.content.split('\n');
                                    historyBuffer = currentLines;
                                    loadedHistoryLines = data.currentPageLines;
                                    totalHistoryLines = data.totalLines;
                                    
                                    terminal.clear();
                                    terminal.write('üìÑ Loading tmux history...\r\n\r\n');
                                    buildContinuousBuffer();
                                    
                                    // Setup scroll detection
                                    setTimeout(setupScrollDetection, 1000);
                                    
                                    // Scroll to bottom
                                    setTimeout(() => {
                                        const xtermViewport = document.querySelector('.xterm-viewport');
                                        if (xtermViewport) {
                                            xtermViewport.scrollTop = xtermViewport.scrollHeight;
                                        }
                                    }, 500);
                                }
                                break;
                                
                            case 'tmux-realtime':
                                // Enhanced duplicate filtering with comprehensive debugging
                                if (data.content) {
                                    console.log('üì® Received tmux content:', JSON.stringify(data.content));
                                    
                                    // Check for duplicate before processing
                                    if (isDuplicateOfLastCommand(data.content)) {
                                        console.log('üö´ FILTERED DUPLICATE:', data.content.trim());
                                        return; // Skip displaying this content
                                    }
                                    
                                    console.log('‚úÖ Displaying content:', data.content.trim());
                                    
                                    // Add new content to buffer
                                    const newLines = data.content.split('\n').filter(line => line.trim() !== '');
                                    if (newLines.length > 0) {
                                        historyBuffer = historyBuffer.concat(newLines);
                                    }
                                    
                                    // Handle spinner patterns
                                    if (data.content.includes('Thinking...')) {
                                        terminal.write('\r\x1b[2K' + data.content.replace(/\r/g, ''));
                                    } else if (data.content.includes('\r')) {
                                        terminal.write(data.content);
                                    } else {
                                        terminal.write(data.content + '\r\n');
                                        
                                        // Auto-scroll to bottom for new content
                                        setTimeout(() => {
                                            const xtermViewport = document.querySelector('.xterm-viewport');
                                            if (xtermViewport) {
                                                const isNearBottom = xtermViewport.scrollTop + xtermViewport.clientHeight >= xtermViewport.scrollHeight - 100;
                                                if (isNearBottom) {
                                                    xtermViewport.scrollTop = xtermViewport.scrollHeight;
                                                }
                                            }
                                        }, 50);
                                    }
                                }
                                break;
                                
                            case 'tmux-incremental-history':
                                // Handle incremental history
                                if (data.content) {
                                    const newHistoryLines = data.content.split('\n').filter(line => line.trim() !== '');
                                    prependHistoryToBuffer(newHistoryLines);
                                }
                                isLoadingHistory = false;
                                break;
                                
                            default:
                                console.log('Ignoring message type:', data.type);
                        }
                    } catch (error) {
                        console.error('Error processing WebSocket message:', error);
                    }
                };
                
                ws.onclose = function() {
                    console.log('üîå WebSocket connection closed');
                    updateConnectionStatus('disconnected', 'Connection lost');
                    
                    terminal.writeln('\r\nüîå Connection lost. Attempting to reconnect...');
                    
                    // Auto-reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
                
                ws.onerror = function(error) {
                    console.error('‚ùå WebSocket error:', error);
                    updateConnectionStatus('disconnected', 'Connection error');
                };
                
            } catch (error) {
                console.error('‚ùå Error creating WebSocket:', error);
                updateConnectionStatus('disconnected', 'Connection failed');
                setTimeout(connectWebSocket, 5000);
            }
        }

        // Continuous buffer functions
        function buildContinuousBuffer() {
            terminal.clear();
            for (let i = 0; i < historyBuffer.length; i++) {
                terminal.write(historyBuffer[i] + '\r\n');
            }
            console.log('üìú Rebuilt continuous buffer with', historyBuffer.length, 'lines');
        }
        
        function prependHistoryToBuffer(newHistoryLines) {
            historyBuffer = newHistoryLines.concat(historyBuffer);
            loadedHistoryLines += newHistoryLines.length;
            
            console.log('üìú Added', newHistoryLines.length, 'history lines. Total:', historyBuffer.length);
            buildContinuousBuffer();
            
            setTimeout(() => {
                const xtermViewport = document.querySelector('.xterm-viewport');
                if (xtermViewport) {
                    xtermViewport.scrollTop = newHistoryLines.length * 20;
                }
            }, 100);
        }
        
        // Scroll detection for continuous loading (COPIED FROM WORKING terminal.html)
        function setupScrollDetection() {
            console.log('üîß Setting up continuous scroll detection...');
            
            // Target the xterm viewport - this is the actual scrollable element!
            const xtermViewport = document.querySelector('.xterm-viewport');
            
            if (xtermViewport) {
                console.log('‚úÖ Found xterm viewport for continuous scrolling');
                console.log('üîß Viewport scroll info:', {
                    scrollHeight: xtermViewport.scrollHeight,
                    clientHeight: xtermViewport.clientHeight,
                    scrollTop: xtermViewport.scrollTop
                });
                
                xtermViewport.addEventListener('scroll', function(e) {
                    const scrollTop = xtermViewport.scrollTop;
                    const scrollHeight = xtermViewport.scrollHeight;
                    const clientHeight = xtermViewport.clientHeight;
                    
                    console.log('üìú Xterm scroll position:', scrollTop, '/', scrollHeight);
                    
                    // If user scrolled near the top and we have more history
                    if (scrollTop < 200 && loadedHistoryLines < totalHistoryLines && !isLoadingHistory) {
                        console.log('üîÑ Loading more history for continuous scrolling...');
                        loadMoreHistoryForContinuous();
                    }
                });
                
                console.log('‚úÖ Continuous scroll detection setup complete on xterm viewport');
            } else {
                console.log('‚ùå Xterm viewport not found, retrying...');
                setTimeout(setupScrollDetection, 2000);
            }
        }
        
        // Load more history for continuous scrolling (COPIED FROM WORKING terminal.html)
        function loadMoreHistoryForContinuous() {
            if (ws && ws.readyState === WebSocket.OPEN && loadedHistoryLines < totalHistoryLines && !isLoadingHistory) {
                isLoadingHistory = true;
                
                const offset = loadedHistoryLines + 50; // Load from where we left off
                const limit = 50;
                
                console.log('üìú Loading continuous history at offset:', offset, 'total loaded:', loadedHistoryLines, '/', totalHistoryLines);
                
                const message = {
                    type: 'load-incremental-history',
                    offset: offset,
                    limit: limit
                };
                
                ws.send(JSON.stringify(message));
            }
        }

        // UI helper functions
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('sessionStatus');
            const detailsElement = document.getElementById('sessionDetails');
            
            statusElement.className = `session-status ${status}`;
            detailsElement.textContent = message;
        }

        function reconnectWebSocket() {
            if (ws) {
                ws.close();
            }
            connectWebSocket();
        }

        // Initialize
        console.log('ü§ñ Pure Tmux Mirror Terminal initialized');
        console.log(`üì° WebSocket will connect to ws://localhost:9091/terminal/${currentSessionId}`);
        console.log('üéØ Ready for pure tmux mirroring!');
        
        // Add some test content to ensure scrolling works
        terminal.writeln('üß™ SCROLL TEST - Adding content to test scrolling...');
        for (let i = 1; i <= 50; i++) {
            terminal.writeln(`üìú Test line ${i} - This is test content to ensure scrolling works properly`);
        }
        terminal.writeln('üéØ End of test content - scroll should work now');
        terminal.writeln('');
        
        // Auto-connect
        connectWebSocket();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            fitAddon.fit();
            console.log('üîß Terminal refitted on window resize');
        });
        
        // Manual scroll test function (for debugging)
        window.testScroll = function() {
            const xtermViewport = document.querySelector('.xterm-viewport');
            if (xtermViewport) {
                console.log('üß™ Manual scroll test');
                console.log('Before:', {
                    scrollTop: xtermViewport.scrollTop,
                    scrollHeight: xtermViewport.scrollHeight,
                    clientHeight: xtermViewport.clientHeight
                });
                
                xtermViewport.scrollTop = 0; // Scroll to top
                setTimeout(() => {
                    console.log('After scroll to top:', {
                        scrollTop: xtermViewport.scrollTop,
                        scrollHeight: xtermViewport.scrollHeight
                    });
                }, 100);
            } else {
                console.log('‚ùå No viewport found for manual test');
            }
        };
        
        console.log('üí° Use testScroll() in console to manually test scrolling');
    </script>
</body>
</html>
